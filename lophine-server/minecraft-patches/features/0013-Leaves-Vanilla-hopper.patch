From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Helvetica Volubi <suisuroru@blue-millennium.fun>
Date: Mon, 28 Jul 2025 01:06:40 +0800
Subject: [PATCH] Leaves: Vanilla hopper

Co-authored by: violetc <58360096+s-yh-china@users.noreply.github.com>
As a part of : Leaves (https://github.com/LeavesMC/Leaves/blob/2c9f83c7b99178851edf5608b37b8c2adddd93cd/leaves-server/minecraft-patches/features/0095-Vanilla-hopper.patch)
Licensed under: GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html)

diff --git a/net/minecraft/world/level/block/entity/HopperBlockEntity.java b/net/minecraft/world/level/block/entity/HopperBlockEntity.java
index 8ba900fda7cce45679cde2b8b3272654129135ca..9d7ec9f4f18ed263540ccddf16c6c1a92d3477a4 100644
--- a/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -280,36 +280,49 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
         ItemStack movedItem = origItemStack;
         final int originalItemCount = origItemStack.getCount();
         final int movedItemCount = Math.min(level.spigotConfig.hopperAmount, originalItemCount);
-        container.setChanged(); // original logic always marks source inv as changed even if no move happens.
-        movedItem.setCount(movedItemCount);
 
-        if (!worldData.skipPullModeEventFire) { // Folia - region threading
-            movedItem = callPullMoveEvent(hopper, container, movedItem);
-            if (movedItem == null) { // cancelled
+        // Leaves start - fix vanilla
+        if (fun.bm.lophine.config.modules.misc.RedStoneConfig.vanillaHopper && movedItem.getCount() <= movedItemCount) {
+            movedItem = origItemStack.copy();
+            final ItemStack remainingItem = addItem(container, hopper,  container.removeItem(i, movedItemCount), null);
+            if (remainingItem.isEmpty()) {
+                container.setChanged();
+            return true;
+        }
+            container.setItem(i, movedItem);
+        } else {
+            container.setChanged(); // original logic always marks source inv as changed even if no move happens.
+            movedItem.setCount(movedItemCount);
+
+            if (!worldData.skipPullModeEventFire) {
+                movedItem = callPullMoveEvent(hopper, container, movedItem);
+                if (movedItem == null) { // cancelled
+                    origItemStack.setCount(originalItemCount);
+                    // Drastically improve performance by returning true.
+                    // No plugin could have relied on the behavior of false as the other call
+                    // site for IMIE did not exhibit the same behavior
+                    return true;
+                }
+            }
+            final ItemStack remainingItem = addItem(container, hopper, movedItem, null);
+            final int remainingItemCount = remainingItem.getCount();
+            if (remainingItemCount != movedItemCount) {
+                origItemStack = origItemStack.copy(true);
                 origItemStack.setCount(originalItemCount);
-                // Drastically improve performance by returning true.
-                // No plugin could have relied on the behavior of false as the other call
-                // site for IMIE did not exhibit the same behavior
+                if (!origItemStack.isEmpty()) {
+                    origItemStack.setCount(originalItemCount - movedItemCount + remainingItemCount);
+                }
+
+                IGNORE_TILE_UPDATES.set(true);
+                container.setItem(i, origItemStack);
+                IGNORE_TILE_UPDATES.set(false);
+                container.setChanged();
                 return true;
             }
-        }
-
-        final ItemStack remainingItem = addItem(container, hopper, movedItem, null);
-        final int remainingItemCount = remainingItem.getCount();
-        if (remainingItemCount != movedItemCount) {
-            origItemStack = origItemStack.copy(true);
             origItemStack.setCount(originalItemCount);
-            if (!origItemStack.isEmpty()) {
-                origItemStack.setCount(originalItemCount - movedItemCount + remainingItemCount);
-            }
 
-            IGNORE_TILE_UPDATES.set(true); // Folia - region threading
-            container.setItem(i, origItemStack);
-            IGNORE_TILE_UPDATES.set(false); // Folia - region threading
-            container.setChanged();
-            return true;
         }
-        origItemStack.setCount(originalItemCount);
+        // Leaves end - fix vanilla
 
         if (level.paperConfig().hopper.cooldownWhenFull) {
             applyCooldown(hopper);
